<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="./styles/global.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>

  </style>
</head>


<body class="m-0 p-0 mx-auto" style="max-width: 600px;">
  <nav id="navCont" class="navbar">
    <div class="container-fluid">
      <a class="navbar-brand" href="/nfl-pickem/index.html">
        <div class="d-flex align-items-center mx-0 px-0">
          <i class="fa-solid fa-football fa-sm d-inline-block align-text-top"></i>
          <span class="ps-2">PICK 'EM</span>
        </div>
      </a>
      <div class="navbar-nav d-flex flex-row nav-underline">
        <a id="nav-standings" class="nav-link fw-medium active" href="/nfl-pickem/index.html">Standings</a>
        <a id="nav-schedule" class="nav-link fw-medium" href="/nfl-pickem/schedule.html">Schedule</a>
      </div>
    </div>
  </nav>

  <div id="main" class="container-fluid mx-0 mt-4">
    <div id="chartFilters" class="row mx-0 mb-3">
      <div class="col px-1">
        <label for="playerSelector" class="form-label text-dim1 text-sm3">PLAYER</label>
        <select id="playerSelector" class="form-select bg-main" aria-label="Player Selector">
        </select>
      </div>
      <div class="col px-1">
        <label for="fieldSelector" class="form-label text-dim1 text-sm3">FIELD</label>
        <select id="fieldSelector" class="form-select bg-main" aria-label="Field Selector">
        </select>
      </div>
    </div>

    <div id="chartDiv" class="chart-container">
      <canvas id="chart" width="300" height="500"></canvas>
    </div>
  </div>

  <script src="./scripts/getSheet.js"></script>
  <script>
    let DATA = {
      Stats: [],
      Chart: {
        labels: [],
        players: [],
        fields: [],
        data: [],
      },
    };

    let chart;

    sendData();

    /* ------------------------------------------------ */

    async function sendData() {
      const data = await getSheet('PlayerStats');
      procStats(data);
      procChartData();

      // previewData(DATA.Chart);
      makeChartFilters();
      // generateChart();
      // updateChart();
    }

    function procChartData() {
      let data = DATA.Stats;

      let weeks = [...new Set(data.map((x) => 'WK ' + x.week))];
      DATA.Chart.labels = weeks;
      // make field objs, converting raw name into 'label'
      let fields = Object.keys(data[0]);
      fields = fields.filter((f) => !['player', 'week', 'rankOrder', 'rankVal'].includes(f));
      fields = fields.map((f) => {
        let label = f.replace(/_/g, ' ');
        label = label.replace('wpct', 'Win %');
        label = label.replace('pct', '%');
        label = label.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
        label = label.replace('Games Back', 'GB');
        // if cum, add ' (cumul.)' to label
        if (f.includes('cum')) {
          label += ' (cumul)';
          label = label.replace('Cum ', '');
        }

        let obj = {
          field: f,
          label: label,
        };
        return obj;
      });

      // let fields = [
      //   { field: 'rank', label: 'Rank', min: 1, max: 9, reverse: true },
      //   { field: 'games_back', label: 'GB', min: 0, max: Math.max(...data.map((x) => x.games_back)), reverse: true },
      //   { field: 'cum_wpct', label: 'Win % (cumul.)', min: .4, max: .6 },
      //   { field: 'cum_dog_pct', label: 'Dog % (cumul.)', min: .1, max: .2 },
      //   { field: 'cum_dog_wpct', label: 'Dog Win % (cumul.)', min: .2, max: .4 },
      // ];



      DATA.Chart.fields = fields;

      let players = [...new Set(data.map((x) => x.player))];
      DATA.Chart.players = players;

      DATA.Chart.data = data.map((x) => {
        let obj = {};
        let fields = Object.keys(x);
        fields = fields.filter((f) => !['rankOrder', 'rankVal'].includes(f));
        fields.forEach((f) => {
          let val = x[f];
          let display = val;
          if (f == 'rank') {
            val = x['rankVal'];
            display = x['rank'];
          }
          if (f.includes('pct')) {
            display = Math.round(val * 100) + '%';
          }
          obj[f] = {
            v: val,
            d: display,
          };
        });
        return obj;
      })
      // fields.forEach((f) => {
      //   let dataset = f;
      //   dataset.data = {};

      //   players.forEach((p) => {
      //     let playerData = data.filter((x) => x.player == p);
      //     dataset.data[p] = playerData.map((x) => {
      //       return {
      //         player: x.player,
      //         week: x.week,
      //         value: x[f.field],
      //       };
      //     });
      //   });

      //   // add 'Average' line
      //   // let weeks = [...new Set(data.map((x) => x.week))];
      //   dataset.data['Average'] = [];
      //   weeks.forEach((w) => {
      //     let weekData = data.filter((x) => x.week == w);
      //     let weekValues = weekData.map((x) => x[f.field]);
      //     let sum = weekValues.reduce((a, b) => a + b, 0);
      //     let avg = sum / weekValues.length;
      //     dataset.data['Average'].push({
      //       player: 'Average',
      //       week: w,
      //       value: avg,
      //     });
      //   });

      //   chartData.datasets.push(dataset);
      // });

      // return chartData;
    }


    /* ------------------------------------------------ */

    // want to give user option to switch field on chart, and player(s) on chart
    // add buttons or dropdowns to chartDiv
    // on click, updateChart(playerName, fieldName)
    function makeChartFilters() {
      let chartDiv = document.getElementById('chartFilters');
      let chartData = DATA.Chart;
      let fields = chartData.fields;
      let players = chartData.players;

      // field selector (only one field at a time)
      let fieldSelector = document.getElementById('fieldSelector');
      fieldSelector.addEventListener('change', function () {
        updateChart();
      });
      fields.forEach((f) => {
        let field = f.field;
        let label = f.label;
        let option = document.createElement('option');
        option.setAttribute('value', field);
        option.innerText = label;
        fieldSelector.appendChild(option);
      });

      let playerSelector = document.getElementById('playerSelector');
      playerSelector.addEventListener('change', function () {
        updateChart();
      });
      let option = document.createElement('option');
      option.setAttribute('value', 'All Players');
      option.setAttribute('selected', true);
      option.innerText = 'All Players';
      playerSelector.appendChild(option);
      players.forEach((p) => {
        if (p == 'Average') return;
        let option = document.createElement('option');
        option.setAttribute('value', p);
        option.innerText = p;
        playerSelector.appendChild(option);
      });
    }

    /* ------------------------------------------------ */

    function updateChart() {

      let chartData = DATA.Chart;
      let playerNames = document.getElementById('playerSelector').value;
      if (playerNames == 'All Players') {
        playerNames = chartData.players;
        // playerNames = playerNames.filter((x) => x != 'Average');
      } else {
        playerNames = [playerNames];
        // playerNames.push('Average');
      }
      let fieldName = document.getElementById('fieldSelector').value;
      // DATA.ChartFilters.players = playerNames;
      // DATA.ChartFilters.field = fieldName;

      let config = chart.config;
      config.data.datasets = [];
      playerNames.forEach((p) => {
        let playerData = chartData.data.filter((x) => x.player.v == p);
        let dataset = {
          type: 'line',
          label: p,
          data: playerData.map((x) => x[fieldName].v),
        };
        // dataset = styleDataset(dataset);
        config.data.datasets.push(dataset);
      });


      // let config = chart.config;
      // config.data.datasets = [];
      // let players = DATA.ChartFilters.players;
      // let field = DATA.ChartFilters.field;
      // players.forEach((p) => {
      //   let playerData = chartData.datasets.filter((x) => x.label == field)[0].data[p];
      //   let dataset = {
      //     label: p,
      //     data: playerData.map((x) => {
      //       return {
      //         x: x.week,
      //         y: x.value,
      //       };

      //     })
      //   };
      //   dataset = styleDataset(dataset);
      //   config.data.datasets.push(dataset);
      // });

      // let fieldData = chartData.datasets.filter((x) => x.label == field)[0];
      // let scales = fieldData.options.scales;
      // if (scales.y.min != null) {
      //   config.options.scales.y.suggestedMin = scales.y.min;
      // } else {
      //   config.options.scales.y.suggestedMin = null;
      // }
      // if (scales.y.max != null) {
      //   config.options.scales.y.suggestedMax = scales.y.max;
      // } else {
      //   config.options.scales.y.suggestedMax = null;
      // }
      // if (scales.y.reverse != null) {
      //   config.options.scales.y.reverse = scales.y.reverse;
      // } else {
      //   config.options.scales.y.reverse = false;
      // }

      // if (field.includes('%')) {
      //   config.options.scales.y.ticks.callback = function (value, index, values) {
      //     return Math.round(value * 100) + '%';
      //   };
      // } else {
      //   config.options.scales.y.ticks.callback = function (value, index, values) {
      //     return value;
      //   };
      // }

      chart.update();
    }
    /* ------------------------------------------------ */

    function getPlayerColors() {
      let players = DATA.Chart.players;
      let colors = ['#0d6efd', '#6f42c1', '#d63384', '#dc3545', '#fd7e14', '#ffc107', '#198754', '#20c997', '#0dcaf0', '#6c757d', '#adb5bd', '#212529'];
      let playerColors = {};
      players.forEach((p, i) => {
        let c = colors[i];
        playerColors[p] = {
          color: c + 'cc',
          colorAlpha: c + '33',
        };
      });
      return playerColors;
    }

    /* ------------------------------------------------ */

    function styleDataset(dataset) {

      let color, colorAlpha;
      let playerColors = getPlayerColors()[dataset.label];
      if (playerColors) {
        color = playerColors.color;
        colorAlpha = playerColors.colorAlpha;
      } else {
        color = 'rgb(255, 255, 255, .4)';
        colorAlpha = 'rgb(255, 255, 255, .2)';
      }

      let d = dataset;
      d.fill = false;
      d.backgroundColor = color;
      d.borderColor = color;
      d.borderWidth = 3;
      d.tension = 0.2;
      d.pointRadius = 3;
      d.pointBackgroundColor = colorAlpha;
      d.pointBorderColor = color;
      d.pointBorderWidth = 3;

      return d;
    }

    /* ------------------------------------------------ */

    function generateChart() {

      let ctx = document.getElementById('chart').getContext('2d');
      let options = getChartOptions();
      let config = {
        type: 'line',
        data: {
          labels: DATA.Chart.labels,
          datasets: [],
        },
        options: options,
      };

      // config.options.onClick = function (event, elements) {
      //   let chart = this;
      //   let playerColors = getPlayerColors();

      //   chart.data.datasets.forEach((d) => {
      //     let c = playerColors[d.label];
      //     d.borderColor = c.color;
      //     d.backgroundColor = c.colorAlpha;
      //     d.pointBorderColor = c.color;
      //     d.pointBackgroundColor = c.colorAlpha;
      //   });
      //   chart.update();
      // };

      // config.options.plugins.legend.onClick = function (event, legendItem, legend) {
      //   let chart = this.chart;
      //   let playerColors = getPlayerColors();
      //   let clickedDataset = chart.data.datasets[legendItem.datasetIndex];
      //   let c = playerColors[clickedDataset.label];
      //   clickedDataset.borderColor = c.color;
      //   clickedDataset.backgroundColor = c.colorAlpha;
      //   clickedDataset.pointBorderColor = c.color;
      //   clickedDataset.pointBackgroundColor = c.colorAlpha;

      //   let otherDatasets = chart.data.datasets.filter((x) => x.label != clickedDataset.label);

      //   otherDatasets.forEach((d) => {
      //     d.borderColor = 'rgba(255, 255, 255, .2)';
      //     d.backgroundColor = 'rgba(255, 255, 255, .05)';
      //     d.pointBorderColor = 'rgba(255, 255, 255, .05)';
      //     d.pointBackgroundColor = 'rgba(255, 255, 255, 0)';
      //   });
      //   chart.update();
      // };

      chart = new Chart(ctx, config);
    }

    /* ------------------------------------------------ */

    // function to set chart config options

    function getChartOptions() {

      let colors = {
        defaultText: 'rgb(255, 255, 255, .85)',
        legendText: 'rgb(255, 255, 255, .85)',
        axisText: 'rgb(255, 255, 255, .6)',
        gridLine: 'rgb(255, 255, 255, .05)',
        tooltipBg: 'rgba(0, 0, 0, .8)',
        tooltipTitle: 'rgba(255, 255, 255, .85)',
        tooltipBody: 'rgba(255, 255, 255, .85)',
      };

      let fonts = {
        default: { size: 12, weight: '500' },
        legend: { size: 14, weight: '500' },
        axis: { size: 12, weight: '500' },
        tooltipTitle: { size: 14, weight: '500' },
        tooltipBody: { size: 12, weight: '500' },
      };

      let title = {};
      title.display = false;

      let legend = {};
      legend.display = true;
      legend.position = 'top';
      legend.align = 'center';
      legend.labels = {};
      legend.labels.color = colors.legendText;
      legend.labels.padding = 20;
      legend.labels.usePointStyle = true;
      legend.labels.font = fonts.legend;

      let x = {};
      x.offset = true;
      x.grid = {};
      x.grid.display = false;
      x.grid.color = colors.gridLine;
      x.ticks = {};
      x.ticks.color = colors.axisText;
      x.ticks.padding = 8;
      x.ticks.maxRotation = 90;
      x.ticks.minRotation = 0;
      x.border = {};
      x.border.display = false;

      let y = {};
      y.offset = true;
      y.grid = {};
      y.grid.color = colors.gridLine;
      y.grid.drawTicks = false;
      y.grid.drawBorder = false;
      y.ticks = {};
      y.ticks.color = colors.axisText;
      y.ticks.padding = 0;
      y.border = {};
      y.border.display = false;

      let tooltip = {};
      tooltip.enabled = false;
      tooltip.backgroundColor = colors.tooltipBg;
      tooltip.titleColor = colors.tooltipTitle;
      tooltip.bodyColor = colors.tooltipBody;
      tooltip.titleFont = fonts.tooltipTitle;
      tooltip.bodyFont = fonts.tooltipBody;
      tooltip.padding = 8;
      tooltip.cornerRadius = 4;
      tooltip.borderWidth = 0;

      let options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: title,
          legend: legend,
          tooltip: tooltip,
        },
        scales: {
          x: x,
          y: y,
        },
      };

      return options;
    }

    /* ------------------------------------------------ */

    function procStats(PlayerStats) {
      let raw = PlayerStats;
      raw.forEach((x) => {
        let fields = Object.keys(x);
        let fieldsStr = ['player', 'rank'];
        let fieldsInt = fields.filter((f) => !fieldsStr.includes(f));
        let fieldsPct = fields.filter((f) => f.includes('pct'));
        fieldsInt = fieldsInt.filter((f) => !fieldsPct.includes(f));
        fieldsInt.forEach((f) => {
          x[f] = parseInt(x[f]);
        });
        fieldsPct.forEach((f) => {
          x[f] = parseFloat(x[f]);
        });

      });

      let fields = Object.keys(raw[0]);
      let wkFields = fields.filter((f) => f.includes('wk_'));
      wkFields.forEach((f) => {
        let cumField = f.replace('wk_', '');
        let newCumFieldName = 'cum_' + cumField;
        raw.forEach((x) => {
          x[newCumFieldName] = x[cumField];
          x[cumField] = x[f];
          delete x[f];
        });
      });

      let data = raw;
      DATA.Stats = data;
    }

    function previewData(dataset) {
      let code = '<div><pre>' + JSON.stringify(dataset, null, 2) + '</pre></div>';
      // document.body.appendChild(document.createRange().createContextualFragment(code));
      document.body.innerHTML = code;
    }


    // if player zooms, limit to 4 weeks

    // callbacks: {
    //   label: function (context) {
    //     let label = context.dataset.label || '';
    //     if (label) {
    //       label += ': ';
    //     }
    //     if (context.parsed.y !== null) {
    //       // format as percent if field is a percent
    //       if (DATA.ChartFilters.field.includes('%')) {
    //         label += Math.round(context.parsed.y * 100) + '%';
    //       } else {
    //         label += context.parsed.y;
    //       }
    //     }
    //     return label;
    //   },
    //   title: function (context) {
    //     let title = context[0].label || '';
    //     return title;
    //   },

    // },

    //       Chart.defaults.font.size = 12;
    // Chart.defaults.font.weight = '500';
    // Chart.defaults.color = 'rgba(255, 255, 255, .85)';

    // let colorAx = 'rgb(255, 255, 255, .6)';
    // let colorGrid = 'rgb(255, 255, 255, .05)';

  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous">
  </script>
</body>

</html>